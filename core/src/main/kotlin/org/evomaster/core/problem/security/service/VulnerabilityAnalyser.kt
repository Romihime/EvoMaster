package org.evomaster.core.problem.security.service

import com.google.inject.Inject
import org.evomaster.core.EMConfig
import org.evomaster.core.languagemodel.service.LanguageModelConnector
import org.evomaster.core.logging.LoggingUtil
import org.evomaster.core.problem.api.param.Param
import org.evomaster.core.problem.rest.builder.RestIndividualSelectorUtils
import org.evomaster.core.problem.rest.data.RestCallAction
import org.evomaster.core.problem.rest.data.RestIndividual
import org.evomaster.core.problem.rest.param.BodyParam
import org.evomaster.core.problem.rest.param.HeaderParam
import org.evomaster.core.problem.security.VulnerabilityClass
import org.evomaster.core.problem.security.data.ActionMapping
import org.evomaster.core.problem.security.data.InputMapping
import org.evomaster.core.problem.security.vulnerabilities.SSRFVulnerability
import org.evomaster.core.search.EvaluatedIndividual
import org.evomaster.core.search.Solution
import org.evomaster.core.search.gene.Gene
import org.evomaster.core.search.service.Archive
import org.evomaster.core.search.service.FitnessFunction
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import javax.annotation.PostConstruct
import javax.annotation.PreDestroy

class VulnerabilityAnalyser {

    @Inject
    private lateinit var config: EMConfig

    @Inject
    private lateinit var fitness: FitnessFunction<RestIndividual>

    /**
     * Archive including test cases
     */
    @Inject
    private lateinit var archive: Archive<RestIndividual>

    @Inject
    private lateinit var languageModelConnector: LanguageModelConnector

    /**
     * [HttpCallbackVerifier] to verify HTTP callbacks for vulnerability classes
     * related to HTTP calls.
     * i.e., SSRF, XXE
     */
    @Inject
    private lateinit var httpCallbackVerifier: HttpCallbackVerifier

    private var actionVulnerabilityMapping: MutableMap<String, ActionMapping> = mutableMapOf()

    /**
     * Individuals in the solution.
     * Derived from archive.
     */
    private lateinit var individualsInSolution: List<EvaluatedIndividual<RestIndividual>>

    companion object {
        private val log: Logger = LoggerFactory.getLogger(VulnerabilityAnalyser::class.java)
    }

    @PostConstruct
    fun init() {
        if (config.vulnerabilityAnalyser) {
//            httpCallbackVerifier = HttpCallbackVerifier()
        }
    }

    @PreDestroy
    private fun preDestroy() {
        if (config.vulnerabilityAnalyser) {
            actionVulnerabilityMapping.clear()
        }
    }


    fun applyVulnerabilityAnalyser(): Solution<RestIndividual> {
        LoggingUtil.Companion.getInfoLogger().info("Applying {}", VulnerabilityAnalyser::class.simpleName)

        // extract individuals from the archive
        val individuals = this.archive.extractSolution().individuals

        individualsInSolution =
            RestIndividualSelectorUtils.findIndividuals(
                individuals,
                statusCodes = listOf(200, 201)
            )

        if (individualsInSolution.isEmpty()) {
            return archive.extractSolution()
        }

        if (!httpCallbackVerifier.isActive) {
            httpCallbackVerifier.initWireMockServer()
        } else {
            httpCallbackVerifier.resetHTTPVerifier()
        }

        LoggingUtil.Companion.getInfoLogger().info("Total individuals before vulnerability analysis: {}", individualsInSolution.size)
        // The below steps are generic, for future extensions can be
        // accommodated easily under these common steps.

        // Classify endpoints with potential vulnerability classes
        classify()

        // execute
        analyse()

        val individualsAfterExecution = RestIndividualSelectorUtils.findIndividuals(
            this.archive.extractSolution().individuals,
            statusCodes = listOf(200, 201)
        )

        LoggingUtil.Companion.getInfoLogger().info("Total individuals after vulnerability analysis: {}", individualsAfterExecution.size)

        return archive.extractSolution()
    }

    fun hasVulnerabilities(
        action: RestCallAction,
    ): Boolean {
        // TODO: Check the action has any vulnerabilities based on the classification
        /*
            WRONG: need to check that test call is using a URL, and that this trigger the fault.
            otherwise, any test with this action type would be marked as faulty

            should check the content of rcr result
         */

        var hasCallbackURL = false

        action.parameters.forEach { param ->
            param.primaryGene().getViewOfChildren().forEach { gene ->
                hasCallbackURL = httpCallbackVerifier.isCallbackURL(gene.getValueAsRawString())
            }
        }

        return hasCallbackURL
    }

    /**
     * Classify endpoints to apply security tests based on the
     * potential security classes scope
     */
    fun classify() {
        // TODO: We need to store word bag of potential input names
        //  if we are going to classify using the variable names.
        //  Other approach is to rely on the API doc with explicit
        //  definitions of potential vulnerability classes.
        //  This is for SSRF.
        //  For SQLi we can consider individuals with SQL actions.
        //  Are we going mark potential vulnerability classes as one time
        //  job or going to evaluate each time (which is costly).

        when (config.vulnerabilitySelectionStrategy) {
            EMConfig.VulnerabilitySelectionStrategy.MANUAL -> {
                manualClassifier()
            }

            EMConfig.VulnerabilitySelectionStrategy.LLM -> {
                llmClassifier()
            }
        }
    }

    /**
     * TODO: Classify based on manual
     * TODO: Need to rename the word manual to something meaningful later
     */
    private fun manualClassifier() {
        // TODO: Can use the extracted CSV to map the parameter name
        //  to the vulnerability class.
    }


    /**
     * Private method to classify parameters using a large language model.
     */
    private fun llmClassifier() {
        if (!config.languageModelConnector) {
            throw IllegalStateException("Language Model Connector is disabled. Unable to run the classification.")
        }

        // For now, we consider only the individuals selected from [Archive]
        // TODO: This can be isolated to classify at the beginning of the search
        individualsInSolution.forEach { evaluatedIndividual ->
            evaluatedIndividual.evaluatedMainActions().forEach { a ->
                val action = a.action
                if (action is RestCallAction) {
                    val actionMapping = ActionMapping(action.getName())
                    val inputMapping: MutableMap<String, InputMapping> =
                        extractBodyParameters(action.parameters)

                    inputMapping.forEach { paramName, paramMapping ->
                        val answer = if (!paramMapping.description.isNullOrBlank()) {
                            languageModelConnector.query(
                                SSRFVulnerability.Companion.getPromptWithNameAndDescription(
                                    paramMapping.name,
                                    paramMapping.description
                                )
                            )
                        } else {
                            languageModelConnector.query(
                                SSRFVulnerability.Companion.getPromptWithNameOnly(
                                    paramMapping.name
                                )
                            )
                        }

                        if (answer != null && answer.answer == SSRFVulnerability.Companion.SSRF_PROMPT_ANSWER_FOR_POSSIBILITY) {
                            paramMapping.addVulnerabilityClass(VulnerabilityClass.SSRF)
                            actionMapping.addVulnerabilityClass(VulnerabilityClass.SSRF)
                            actionMapping.isVulnerable = true
                        }
                    }

                    // Assign the param mapping
                    actionMapping.params = inputMapping

                    actionVulnerabilityMapping[action.getName()] = actionMapping
                }
            }
        }
    }

    /**
     * Extract descriptions from the Gene of body payloads.
     */
    private fun extractBodyParameters(
        parameters: List<Param>
    ): MutableMap<String, InputMapping> {
        val output = mutableMapOf<String, InputMapping>()

        parameters.forEach { param ->
            when (param) {
                is BodyParam -> {
                    param.seeGenes().filter { it.name == "body" }.forEach { gene ->
                        gene.getAllGenesInIndividual().forEach { geneInIndividual ->
                            output[geneInIndividual.name] = InputMapping(
                                geneInIndividual.name,
                                geneInIndividual.description
                            )
                        }
                    }
                }

                is HeaderParam -> {
                    param.seeGenes().filter { it.name != "body" }.forEach { gene ->
                        output[gene.name] = InputMapping(
                            gene.name,
                            gene.description
                        )
                    }
                }

                else -> {
                    // Do nothing for now
                }
            }
        }

        return output
    }

    /**
     * Run the determined vulnerability class (from the classification)
     * analyzers
     */
    private fun analyse() {
        if (config.problemType == EMConfig.ProblemType.REST) {

            individualsInSolution.forEach { evaluatedIndividual ->
                evaluatedIndividual.evaluatedMainActions().forEach { a ->
                    val action = a.action
                    if (action is RestCallAction) {
                        if (actionVulnerabilityMapping.containsKey(action.getName())
                            && actionVulnerabilityMapping.getValue(action.getName()).isVulnerable
                            && evaluatedIndividual.individual is RestIndividual
                        ) {
                            val mapping = actionVulnerabilityMapping[action.getName()]

                            if (mapping != null) {
                                val copy = evaluatedIndividual.individual.copy() as RestIndividual
                                // TODO: Need individual URL for each param?
                                val callbackURL = httpCallbackVerifier.generateCallbackLink(
                                    action.getName()
                                )

                                copy.seeMainExecutableActions().forEach { action ->
                                    action.parameters.forEach { param ->
                                        updateGeneWithCallbackURL(action.getName(), param.primaryGene(), callbackURL)
                                    }
                                }

                                val executedIndividual = fitness.computeWholeAchievedCoverageForPostProcessing(copy)

                                if (executedIndividual != null) {
                                    // TODO: This have to be extended to mark other vulnerability types in future
                                    actionVulnerabilityMapping.getValue(action.getName()).httpCallbackURL = callbackURL
                                    val result = httpCallbackVerifier.verify(action.getName())
                                    if (result) {
                                        val actionMapping = actionVulnerabilityMapping.getValue(action.getName())
                                        actionMapping.isExploitable = true
                                        actionMapping.vulnerabilityClasses[VulnerabilityClass.SSRF] = true
                                        // Create a testing target
                                        archive.addIfNeeded(executedIndividual)
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    private fun updateGeneWithCallbackURL(actionName: String, primaryGene: Gene, callBackUrl: String) {
        primaryGene.getViewOfChildren().forEach { gene ->
            if (actionVulnerabilityMapping.containsKey(actionName)) {
                val g = actionVulnerabilityMapping[actionName]!!.params[gene.name]
                if (g!!.vulnerabilityClasses.contains(VulnerabilityClass.SSRF)) {
                    // Only change the param marked for SSRF
                    gene.setFromStringValue(callBackUrl)
                }
            }
        }
    }
}
