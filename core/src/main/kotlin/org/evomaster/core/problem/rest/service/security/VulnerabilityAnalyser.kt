package org.evomaster.core.problem.rest.service.security

import com.google.inject.Inject
import org.evomaster.core.problem.rest.RestIndividual
import org.evomaster.core.problem.rest.service.SecurityRest
import org.evomaster.core.search.EvaluatedIndividual
import org.evomaster.core.search.Solution
import org.evomaster.core.search.service.Archive
import org.slf4j.Logger
import org.slf4j.LoggerFactory

class VulnerabilityAnalyser {

    companion object {
        private val log: Logger = LoggerFactory.getLogger(SecurityRest::class.java)
    }

    /**
     * Archive including test cases
     */
    @Inject
    private lateinit var archive: Archive<RestIndividual>

    /**
     * Individuals in the solution.
     * Derived from archive.
     */
    private lateinit var individualsInSolution: List<EvaluatedIndividual<RestIndividual>>


    fun applyVulnerabilityAnalyser(): Solution<RestIndividual> {
        // extract individuals from the archive
        individualsInSolution = this.archive.extractSolution().individuals

        // The below steps are generic, for future extensions can be
        // accommodated easily under these common steps.

        // Classify endpoints with potential vulnerability classes
        classify()

        // execute
        analyse()

        // verify after execution
        verify()

        return archive.extractSolution()
    }

    /**
     * Results for [TestSuiteWriter] to use at the end.
     */
    fun getResults() {

    }


    /**
     * Classify endpoints to apply security tests based on the
     * potential security classes scope
     */
    private fun classify() {
        // TODO: We need to store word bag of potential input names
        //  if we are going to classify using the variable names.
        //  Other approach is to rely on the API doc with explicit
        //  definitions of potential vulnerability classes.
        //  This is for SSRF.
        //  For SQLi we can consider individuals with SQL actions.
        //  Are we going mark potential vulnerability classes as one time
        //  job or going to evaluate each time (which is costly).

        // This can be a singleton?
        val vulnerabilityClassifier = VulnerabilityClassifier()
        vulnerabilityClassifier.classify()
    }

    /**
     * Run the determined vulnerability class (from the classification)
     * analysers
     */
    private fun analyse() {

    }

    /**
     * To verify vulnerability existence through [VulnerabilityVerifier]
     * TODO: [VulnerabilityVerifier] pending implementation
     */
    private fun verify() {

        // This should be a singleton
        val vulnerabilityVerifier = VulnerabilityVerifier()
        vulnerabilityVerifier.verify()
    }

}
