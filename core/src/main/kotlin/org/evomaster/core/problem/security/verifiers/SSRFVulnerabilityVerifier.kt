package org.evomaster.core.problem.security.verifiers

import com.github.tomakehurst.wiremock.WireMockServer
import com.github.tomakehurst.wiremock.client.WireMock
import com.github.tomakehurst.wiremock.common.Metadata.metadata
import com.github.tomakehurst.wiremock.core.WireMockConfiguration
import com.github.tomakehurst.wiremock.extension.responsetemplating.ResponseTemplateTransformer
import org.evomaster.client.java.instrumentation.shared.VulnerabilityAnalyserSharedUtils
import org.evomaster.core.problem.security.VulnerabilityVerifier
import java.util.UUID

class SSRFVulnerabilityVerifier : VulnerabilityVerifier() {

    companion object {
        const val SSRF_PROMPT_ANSWER_FOR_POSSIBILITY = "TRUE"
    }

    private var wireMockServer: WireMockServer? = null

    private var traceTokens: MutableMap<String, String> = mutableMapOf()

    override fun init() {
        try {
            val config = WireMockConfiguration()
                .bindAddress(VulnerabilityAnalyserSharedUtils.SSRF_VERIFIER_WM_IP)
                .extensions(ResponseTemplateTransformer(false))
                .port(9000)

            wireMockServer = WireMockServer(config)
            wireMockServer!!.start()
            wireMockServer!!.stubFor(
                WireMock.any(WireMock.anyUrl())
                    .atPriority(1)
                    .willReturn(
                        WireMock.aResponse()
                            .withStatus(200)
                            .withBody("OK")
                    )
            )
        } catch (e: Exception) {
            throw RuntimeException("Failed to initialize SSRFVulnerabilityVerifier. If it is macOS, please make sure loopback alias is set.")
        }
    }

    fun generateLink(name: String): String {
        val token = UUID.randomUUID().toString()
        val ssrfPath = "sink/$token"

        wireMockServer!!.stubFor(
            WireMock.post(WireMock.urlPathMatching(ssrfPath))
                .withMetadata(metadata().attr("originalPath", name))
                .willReturn(
                    WireMock.aResponse()
                        .withStatus(200)
                        .withBody("OK")
                )

        )

        var link = "http://${VulnerabilityAnalyserSharedUtils.SSRF_VERIFIER_WM_IP}:${wireMockServer!!.port()}/$ssrfPath"

        traceTokens[name] = link

        return link
    }

    override fun verify(name: String): Boolean {
        if (wireMockServer!!.allServeEvents.any { it -> it.wasMatched }) {
            wireMockServer!!.allServeEvents.filter { event -> event.wasMatched }
                .forEach { e ->
                    val matched = e.stubMapping.metadata.getString("originalPath")
                    if (matched == name) {
                        return true
                    }
                }
        }
        return false
    }


    private fun resetHTTPVerifier() {
        wireMockServer?.resetAll()
        traceTokens.clear()
    }


    /**
     * This prompt is for SSRF.
     * TODO: In the future, this can be extended to for other classes by using a
     *  custom large language model.
     */
    fun getPromptWithNameAndDescription(name: String, description: String): String {
        return """
            Consider the word "${name}" and the description as "${description}", used as a name identifier 
            for a parameter inside a OpenAPI/Swagger schema. Would it likely represent a URL value ? give me 
            answer as boolean with TRUE or FALSE"""
    }

    /**
     * This prompt is for SSRF.
     * TODO: In the future, this can be extended to for other classes by using a
     *  custom large language model.
     */
    fun getPromptWithNameOnly(name: String): String {
        return """
            Consider the word "${name}", used as a name identifier 
            for a parameter inside a OpenAPI/Swagger schema. Would it likely represent a URL value ? give me 
            answer as boolean with TRUE or FALSE"""
    }
}
