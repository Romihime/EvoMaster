package org.evomaster.core.problem.security

import com.google.inject.Inject
import org.evomaster.core.EMConfig
import org.evomaster.core.languagemodel.service.LanguageModelConnector
import org.evomaster.core.problem.api.param.Param
import org.evomaster.core.problem.rest.builder.RestIndividualSelectorUtils
import org.evomaster.core.problem.rest.data.RestCallAction
import org.evomaster.core.problem.rest.data.RestIndividual
import org.evomaster.core.problem.security.data.ActionMapping
import org.evomaster.core.problem.security.data.ParamMapping
import org.evomaster.core.problem.security.verifiers.SSRFVulnerabilityVerifier
import org.evomaster.core.search.EvaluatedIndividual
import org.evomaster.core.search.Solution
import org.evomaster.core.search.service.Archive
import org.evomaster.core.search.service.FitnessFunction

class VulnerabilityAnalyser {

    @Inject
    private lateinit var config: EMConfig

    @Inject
    private lateinit var fitness: FitnessFunction<RestIndividual>

    /**
     * Archive including test cases
     */
    @Inject
    private lateinit var archive: Archive<RestIndividual>

    @Inject
    private lateinit var languageModelConnector: LanguageModelConnector

    /**
     * TODO: This can be generalized later to accommodate more vulnerability types
     */
    private lateinit var ssrfVerifier: SSRFVulnerabilityVerifier

    private var actionVulnerabilityMapping: MutableMap<String, ActionMapping> = mutableMapOf()

    /**
     * Individuals in the solution.
     * Derived from archive.
     */
    private lateinit var individualsInSolution: List<EvaluatedIndividual<RestIndividual>>


    fun applyVulnerabilityAnalyser(): Solution<RestIndividual> {
        // extract individuals from the archive
        val individuals = this.archive.extractSolution().individuals

        individualsInSolution =
            RestIndividualSelectorUtils.findIndividuals(
                individuals,
                statusCodes = listOf(200)
            )

        ssrfVerifier = SSRFVulnerabilityVerifier()
        ssrfVerifier.init()

        // The below steps are generic, for future extensions can be
        // accommodated easily under these common steps.

        // Classify endpoints with potential vulnerability classes
        classify()

        // execute
        analyseSSRF()


        return archive.extractSolution()
    }


    /**
     * Classify endpoints to apply security tests based on the
     * potential security classes scope
     */
    private fun classify() {
        // TODO: We need to store word bag of potential input names
        //  if we are going to classify using the variable names.
        //  Other approach is to rely on the API doc with explicit
        //  definitions of potential vulnerability classes.
        //  This is for SSRF.
        //  For SQLi we can consider individuals with SQL actions.
        //  Are we going mark potential vulnerability classes as one time
        //  job or going to evaluate each time (which is costly).

        when (config.vulnerabilitySelectionStrategy) {
            EMConfig.VulnerabilitySelectionStrategy.MANUAL -> {
                manualClassifier()
            }

            EMConfig.VulnerabilitySelectionStrategy.LLM -> {
                llmClassifier()
            }
        }
    }

    /**
     * TODO: Classify based on manual
     * TODO: Need to rename the word manual to something meaningful later
     */
    private fun manualClassifier() {
        TODO("Pending discussion")
    }

    /**
     * TODO: Use LLM to classify the URLs
     */
    private fun llmClassifier() {
        individualsInSolution.forEach { evaluatedIndividual ->
            val ea = evaluatedIndividual.evaluatedMainActions()[0].action
            if (ea is RestCallAction) {
                val actionMapping = ActionMapping(ea.getName())
                val paramMapping: MutableMap<String, ParamMapping> =
                    extractBodyParameters(ea.parameters)

                paramMapping.forEach { paramName, description ->
                    val answer = if (!description.description.isNullOrBlank()) {
                        languageModelConnector.query(
                            ssrfVerifier.getPromptWithNameAndDescription(
                                description.name,
                                description.description
                            )
                        )
                    } else {
                        languageModelConnector.query(
                            ssrfVerifier.getPromptWithNameOnly(
                                description.name
                            )
                        )
                    }

                    if (answer == SSRFVulnerabilityVerifier.SSRF_PROMPT_ANSWER_FOR_POSSIBILITY) {
                        description.addVulnerabilityClass(VulnerabilityClass.SSRF)
                        actionMapping.isVulnerable = true
                    }
                }

                // Assign the param mapping
                actionMapping.paramMapping = paramMapping

                actionVulnerabilityMapping[ea.getName()] = actionMapping
            }
        }
    }

    /**
     * Extract descriptions from the Gene of body payloads.
     */
    private fun extractBodyParameters(
        parameters: List<Param>
    ): MutableMap<String, ParamMapping> {
        val output = mutableMapOf<String, ParamMapping>()

        parameters.forEach { param ->
            if (param.name == "body") {
                param.seeGenes().forEach { gene ->
                    if (gene.name == "body") {
                        gene.getAllGenesInIndividual().forEach { geneInIndividual ->
                            val pm = ParamMapping(geneInIndividual.name, geneInIndividual.description)
                            pm.paramType = ParameterType.BODY
                            output[geneInIndividual.name] = pm

                        }
                    } else {
                        val pm = ParamMapping(gene.name, gene.description)
                        pm.paramType = ParameterType.HEADER
                        output[gene.name] = pm
                    }
                }
            }
        }

        return output
    }

    /**
     * Run the determined vulnerability class (from the classification)
     * analyzers
     */
    private fun analyseSSRF() {
        if (config.problemType == EMConfig.ProblemType.REST) {
            individualsInSolution.forEach { evaluatedIndividual ->
                val ea = evaluatedIndividual.evaluatedMainActions()[0].action as RestCallAction
                // Execute only the action which marked as a possible candidate
                if (actionVulnerabilityMapping.containsKey(ea.getName())
                    && actionVulnerabilityMapping.getValue(ea.getName()).isVulnerable
                ) {
                    val honeyPotLink = ssrfVerifier.generateLink(ea.getName())
                    val copy = evaluatedIndividual.copy() as RestIndividual
                    copy.seeMainExecutableActions().last().parameters.forEach { param ->

                    }
                    // TODO: Execute the tests here

                    val executedIndividual = fitness.computeWholeAchievedCoverageForPostProcessing(copy)

                    if (executedIndividual != null) {
                        val result = ssrfVerifier.verify(ea.getName())
                        if (result) {
                            actionVulnerabilityMapping.getValue(ea.getName()).isExploitable = true
                            archive.addIfNeeded(executedIndividual)
                        }
                    }
                }
            }
        }
    }

}
