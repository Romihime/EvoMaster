package org.evomaster.core.problem.security

import com.google.inject.Inject
import org.evomaster.core.EMConfig
import org.evomaster.core.languagemodel.LanguageModelConnector
import org.evomaster.core.problem.api.param.Param
import org.evomaster.core.problem.rest.data.RestCallAction
import org.evomaster.core.problem.rest.data.RestIndividual
import org.evomaster.core.problem.rest.service.SecurityRest
import org.evomaster.core.problem.security.verifiers.SSRFVulnerabilityVerifier
import org.evomaster.core.search.EvaluatedIndividual
import org.evomaster.core.search.Solution
import org.evomaster.core.search.service.Archive
import org.slf4j.Logger
import org.slf4j.LoggerFactory

class VulnerabilityAnalyser {

    companion object {
        private val log: Logger = LoggerFactory.getLogger(SecurityRest::class.java)
    }

    @Inject
    private lateinit var config: EMConfig

    /**
     * Archive including test cases
     */
    @Inject
    private lateinit var archive: Archive<RestIndividual>


    private lateinit var ssrfVerifier: SSRFVulnerabilityVerifier

    private var paramMapping: MutableMap<String, ParamMapping> = mutableMapOf()

    /**
     * Individuals in the solution.
     * Derived from archive.
     */
    private lateinit var individualsInSolution: List<EvaluatedIndividual<RestIndividual>>


    fun applyVulnerabilityAnalyser(): Solution<RestIndividual> {
        // extract individuals from the archive
        individualsInSolution = this.archive.extractSolution().individuals

        ssrfVerifier = SSRFVulnerabilityVerifier()
        ssrfVerifier.init()

        // The below steps are generic, for future extensions can be
        // accommodated easily under these common steps.

        // Classify endpoints with potential vulnerability classes
        classify()

        // execute
        execute()

        // verify after execution
        verify()

        return archive.extractSolution()
    }

    /**
     * Results for [TestSuiteWriter] to use at the end.
     */
    fun getResults() {

    }

    /**
     * Classify endpoints to apply security tests based on the
     * potential security classes scope
     */
    private fun classify() {
        // TODO: We need to store word bag of potential input names
        //  if we are going to classify using the variable names.
        //  Other approach is to rely on the API doc with explicit
        //  definitions of potential vulnerability classes.
        //  This is for SSRF.
        //  For SQLi we can consider individuals with SQL actions.
        //  Are we going mark potential vulnerability classes as one time
        //  job or going to evaluate each time (which is costly).

        // This can be a singleton?
        when (config.vulnerabilitySelectionStrategy) {
            EMConfig.VulnerabilitySelectionStrategy.MANUAL -> {
                manualClassifier()
            }

            EMConfig.VulnerabilitySelectionStrategy.LLM -> {
                llmClassifier()
            }
        }
    }

    /**
     * TODO: Classify based on manual
     * TODO: Need to rename the word manual to something meaningful later
     */
    private fun manualClassifier() {
        TODO("Pending discussion")
    }

    /**
     * TODO: Use LLM to classify the URLs
     */
    private fun llmClassifier() {
        individualsInSolution.forEach { evaluatedIndividual ->
            val ea = evaluatedIndividual.evaluatedMainActions()[0].action
            if (ea is RestCallAction) {
                val descriptions = extractBodyParameterDescriptions(ea.getName(), ea.parameters)
                paramMapping = descriptions

                // Check the parameters can be a URL
                val languageModelConnector = LanguageModelConnector()

                descriptions.forEach { name, description ->
                    // TODO: Have to move it to async.
                    val result = languageModelConnector.query(getPrompt(description.name, description.description))

                    if (result != null) {
                        if (result == "TRUE") {
                            description.addVulnerabilityClass(VulnerabilityClass.SSRF)
                        }
                    }
                }
            }
        }
    }

    /**
     * Extract descriptions from the Gene of body payloads.
     */
    private fun extractBodyParameterDescriptions(name: String, parameters: List<Param>): MutableMap<String, ParamMapping> {
        val output = mutableMapOf<String, ParamMapping>()

        parameters.forEach { param ->
            if (param.name == "body") {
                param.seeGenes().forEach { gene ->
                    if (!gene.description.isNullOrEmpty()) {
                        output[param.name] = ParamMapping(param.name, gene.description.toString())
                    }

                    if (gene.name == "body") {
                        gene.getAllGenesInIndividual().forEach { geneInIndividual ->
                            if (!geneInIndividual.description.isNullOrEmpty()) {
                                output[param.name] = ParamMapping(param.name, gene.description.toString())
                            }
                        }
                    }
                }
            }
        }

        return output
    }

    /**
     * Run the determined vulnerability class (from the classification)
     * analyzers
     */
    private fun execute() {
        if (config.problemType == EMConfig.ProblemType.REST) {
            // TODO: Run the tests again with generated value
            individualsInSolution.forEach { evaluatedIndividual ->
                val ea = evaluatedIndividual.evaluatedMainActions()[0].action as RestCallAction
                val link = ssrfVerifier.generateLink(ea.getName())
            }
        }
    }

    /**
     * To verify vulnerability existence through [VulnerabilityVerifier]
     * TODO: [VulnerabilityVerifier] pending implementation
     */
    private fun verify() {
        if (config.problemType == EMConfig.ProblemType.REST) {
            individualsInSolution.forEach { eI ->
                val ea = eI.evaluatedMainActions()[0].action as RestCallAction
                val result = ssrfVerifier.verify(ea.getName())

                if (result == true) {
                    // TODO: Mark as vulnerable
                }
            }
        }
    }

    /**
     * This prompt is for SSRF.
     * TODO: In the future, this can be extended to for other classes by using a
     *  custom large language model.
     */
    private fun getPrompt(name: String, description: String): String {
        return """
            Consider the word \"${name}\" and the description as \"${description}\", used as a name identifier 
            for a parameter inside a OpenAPI/Swagger schema. Would it likely represent a URL value ? give me 
            answer as boolean with TRUE or FALSE"""
    }

}
