package org.evomaster.core.problem.security

import com.google.inject.Inject
import org.evomaster.core.EMConfig
import org.evomaster.core.languagemodel.service.LanguageModelConnector
import org.evomaster.core.logging.LoggingUtil
import org.evomaster.core.problem.api.param.Param
import org.evomaster.core.problem.rest.builder.RestIndividualSelectorUtils
import org.evomaster.core.problem.rest.data.RestCallAction
import org.evomaster.core.problem.rest.data.RestIndividual
import org.evomaster.core.problem.rest.param.BodyParam
import org.evomaster.core.problem.rest.param.HeaderParam
import org.evomaster.core.problem.security.data.ActionMapping
import org.evomaster.core.problem.security.data.ParamMapping
import org.evomaster.core.problem.security.verifiers.HttpCallbackVerifier
import org.evomaster.core.problem.security.vulnerabilities.SSRFVulnerability
import org.evomaster.core.search.EvaluatedIndividual
import org.evomaster.core.search.Solution
import org.evomaster.core.search.gene.string.StringGene
import org.evomaster.core.search.service.Archive
import org.evomaster.core.search.service.FitnessFunction
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import javax.annotation.PostConstruct
import javax.annotation.PreDestroy
import kotlin.collections.set

class VulnerabilityAnalyser {


    @Inject
    private lateinit var config: EMConfig

    @Inject
    private lateinit var fitness: FitnessFunction<RestIndividual>

    /**
     * Archive including test cases
     */
    @Inject
    private lateinit var archive: Archive<RestIndividual>

    @Inject
    private lateinit var languageModelConnector: LanguageModelConnector

    /**
     * TODO: This can be generalized later to accommodate more vulnerability types
     */
    private lateinit var httpCallbackVerifier: HttpCallbackVerifier

    private var actionVulnerabilityMapping: MutableMap<String, ActionMapping> = mutableMapOf()

    /**
     * Individuals in the solution.
     * Derived from archive.
     */
    private lateinit var individualsInSolution: List<EvaluatedIndividual<RestIndividual>>

    companion object {
        private val log: Logger = LoggerFactory.getLogger(VulnerabilityAnalyser::class.java)
    }

    @PostConstruct
    fun init() {
        if (config.vulnerabilityAnalyser) {
            LoggingUtil.Companion.getInfoLogger().info("Initializing {}", VulnerabilityAnalyser::class.simpleName)

            httpCallbackVerifier = HttpCallbackVerifier()
            httpCallbackVerifier.init()
        }
    }

    @PreDestroy
    private fun preDestroy() {
        if (config.vulnerabilityAnalyser) {
            httpCallbackVerifier.destroy()
        }
    }


    fun applyVulnerabilityAnalyser(): Solution<RestIndividual> {
        // extract individuals from the archive
        val individuals = this.archive.extractSolution().individuals

        individualsInSolution =
            RestIndividualSelectorUtils.findIndividuals(
                individuals,
                statusCodes = listOf(200)
            )

        LoggingUtil.getInfoLogger().info("Total individuals with HTTP 200: {}", individualsInSolution.size)
        // The below steps are generic, for future extensions can be
        // accommodated easily under these common steps.

        // Classify endpoints with potential vulnerability classes
        classify()

        // execute
        analyse()


        return archive.extractSolution()
    }


    /**
     * Classify endpoints to apply security tests based on the
     * potential security classes scope
     */
    private fun classify() {
        // TODO: We need to store word bag of potential input names
        //  if we are going to classify using the variable names.
        //  Other approach is to rely on the API doc with explicit
        //  definitions of potential vulnerability classes.
        //  This is for SSRF.
        //  For SQLi we can consider individuals with SQL actions.
        //  Are we going mark potential vulnerability classes as one time
        //  job or going to evaluate each time (which is costly).

        when (config.vulnerabilitySelectionStrategy) {
            EMConfig.VulnerabilitySelectionStrategy.MANUAL -> {
                manualClassifier()
            }

            EMConfig.VulnerabilitySelectionStrategy.LLM -> {
                llmClassifier()
            }
        }
    }

    /**
     * TODO: Classify based on manual
     * TODO: Need to rename the word manual to something meaningful later
     */
    private fun manualClassifier() {
        // TODO: Can use the extracted CSV to map the parameter name
        //  to the vulnerability class.
    }


    /**
     * Private method to classify parameters using a large language model.
     */
    private fun llmClassifier() {
        individualsInSolution.forEach { evaluatedIndividual ->
            val ea = evaluatedIndividual.evaluatedMainActions()[0].action
            if (ea is RestCallAction) {
                val actionMapping = ActionMapping(ea.getName())
                val paramMapping: MutableMap<String, ParamMapping> =
                    extractBodyParameters(ea.parameters)

                paramMapping.forEach { paramName, description ->
                    val answer = if (!description.description.isNullOrBlank()) {
                        languageModelConnector.query(
                            SSRFVulnerability.getPromptWithNameAndDescription(
                                description.name,
                                description.description
                            )
                        )
                    } else {
                        languageModelConnector.query(
                            SSRFVulnerability.getPromptWithNameOnly(
                                description.name
                            )
                        )
                    }

                    if (answer != null && answer.answer == SSRFVulnerability.SSRF_PROMPT_ANSWER_FOR_POSSIBILITY) {
                        description.addVulnerabilityClass(VulnerabilityClass.SSRF)
                        actionMapping.addVulnerabilityClass(VulnerabilityClass.SSRF)
                        actionMapping.isVulnerable = true
                    }
                }

                // Assign the param mapping
                actionMapping.params = paramMapping

                actionVulnerabilityMapping[ea.getName()] = actionMapping
            }
        }

        LoggingUtil.getInfoLogger().info("Classified using LLM.")
    }

    /**
     * Extract descriptions from the Gene of body payloads.
     */
    private fun extractBodyParameters(
        parameters: List<Param>
    ): MutableMap<String, ParamMapping> {
        val output = mutableMapOf<String, ParamMapping>()

        parameters.forEach { param ->
            when (param) {
                is BodyParam -> {
                    param.seeGenes().filter { it.name == "body" }.forEach { gene ->
                        gene.getAllGenesInIndividual().forEach { geneInIndividual ->
                            output[geneInIndividual.name] = ParamMapping(
                                geneInIndividual.name,
                                geneInIndividual.description
                            )
                        }
                    }
                }

                is HeaderParam -> {
                    param.seeGenes().filter { it.name != "body" }.forEach { gene ->
                        output[gene.name] = ParamMapping(
                            gene.name,
                            gene.description
                        )
                    }
                }

                else -> {
                    // Do nothing for now
                }
            }
        }

        return output
    }

    /**
     * Run the determined vulnerability class (from the classification)
     * analyzers
     */
    private fun analyse() {
        if (config.problemType == EMConfig.ProblemType.REST) {

            individualsInSolution.forEach { evaluatedIndividual ->
                val ea = evaluatedIndividual.evaluatedMainActions()[0].action as RestCallAction
                // Execute only the action which marked as a possible candidate
                if (actionVulnerabilityMapping.containsKey(ea.getName())
                    && actionVulnerabilityMapping.getValue(ea.getName()).isVulnerable
                    && evaluatedIndividual.individual is RestIndividual
                ) {
                    val mapping = actionVulnerabilityMapping[ea.getName()]

                    if (mapping != null) {
                        val copy = evaluatedIndividual.individual.copy() as RestIndividual
                        val callbackLink = httpCallbackVerifier.generateCallbackLink(ea.getName())

                        copy.seeMainExecutableActions()[0].parameters.forEach { param ->
                            param.seeGenes().filter { it.name == "body" }.forEach { gene ->
                                gene.getAllGenesInIndividual().forEach { geneInIndividual ->
                                    if (mapping.params.isNotEmpty()) {
                                        when (geneInIndividual) {
                                            is StringGene -> {
                                                // URL usually StringGene, so we only handle StringGene
                                                val exists = mapping.params.any {
                                                    it.key == geneInIndividual.name && it.value.hasVulnerabilityClass(
                                                        VulnerabilityClass.SSRF
                                                    )
                                                }
                                                if (exists) {
                                                    geneInIndividual.value = callbackLink
                                                }
                                            }

                                            else -> {}
                                        }
                                    }
                                }
                            }
                        }

                        val executedIndividual = fitness.computeWholeAchievedCoverageForPostProcessing(copy)

                        if (executedIndividual != null) {
                            val result = httpCallbackVerifier.verify(ea.getName())
                            if (result) {
                                actionVulnerabilityMapping.getValue(ea.getName()).isExploitable = true
                                archive.addIfNeeded(executedIndividual)
                            }
                        }
                    }
                }
            }
        }
    }
}
