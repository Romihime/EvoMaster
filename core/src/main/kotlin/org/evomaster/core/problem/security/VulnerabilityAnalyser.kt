package org.evomaster.core.problem.security

import com.google.inject.Inject
import org.evomaster.core.EMConfig
import org.evomaster.core.languagemodel.LanguageModelConnector
import org.evomaster.core.problem.api.param.Param
import org.evomaster.core.problem.rest.data.RestCallAction
import org.evomaster.core.problem.rest.data.RestIndividual
import org.evomaster.core.problem.security.data.ParamMapping
import org.evomaster.core.problem.security.verifiers.SSRFVulnerabilityVerifier
import org.evomaster.core.search.EvaluatedIndividual
import org.evomaster.core.search.Solution
import org.evomaster.core.search.service.Archive

class VulnerabilityAnalyser {

    @Inject
    private lateinit var config: EMConfig

    /**
     * Archive including test cases
     */
    @Inject
    private lateinit var archive: Archive<RestIndividual>

    @Inject
    private lateinit var languageModelConnector: LanguageModelConnector


    /**
     * TODO: This can be generalized later to accommodate more vulnerability types
     */
    private lateinit var ssrfVerifier: SSRFVulnerabilityVerifier

    private var actionVulnerabilityMapping: MutableMap<String, MutableMap<String, ParamMapping>> = mutableMapOf()

    /**
     * Individuals in the solution.
     * Derived from archive.
     */
    private lateinit var individualsInSolution: List<EvaluatedIndividual<RestIndividual>>


    fun applyVulnerabilityAnalyser(): Solution<RestIndividual> {
        // extract individuals from the archive
        individualsInSolution = this.archive.extractSolution().individuals

        ssrfVerifier = SSRFVulnerabilityVerifier()
        ssrfVerifier.init()

        // The below steps are generic, for future extensions can be
        // accommodated easily under these common steps.

        // Classify endpoints with potential vulnerability classes
        classify()

        // execute
        execute()

        // verify after execution
        verify()

        return archive.extractSolution()
    }

    /**
     * Results for [TestSuiteWriter] to use at the end.
     */
    fun getResults() {

    }

    /**
     * Classify endpoints to apply security tests based on the
     * potential security classes scope
     */
    private fun classify() {
        // TODO: We need to store word bag of potential input names
        //  if we are going to classify using the variable names.
        //  Other approach is to rely on the API doc with explicit
        //  definitions of potential vulnerability classes.
        //  This is for SSRF.
        //  For SQLi we can consider individuals with SQL actions.
        //  Are we going mark potential vulnerability classes as one time
        //  job or going to evaluate each time (which is costly).

        when (config.vulnerabilitySelectionStrategy) {
            EMConfig.VulnerabilitySelectionStrategy.MANUAL -> {
                manualClassifier()
            }

            EMConfig.VulnerabilitySelectionStrategy.LLM -> {
                llmClassifier()
            }
        }
    }

    /**
     * TODO: Classify based on manual
     * TODO: Need to rename the word manual to something meaningful later
     */
    private fun manualClassifier() {
        TODO("Pending discussion")
    }

    /**
     * TODO: Use LLM to classify the URLs
     */
    private fun llmClassifier() {
        individualsInSolution.forEach { evaluatedIndividual ->
            val ea = evaluatedIndividual.evaluatedMainActions()[0].action
            if (ea is RestCallAction) {
                val descriptions : MutableMap<String, ParamMapping> = extractBodyParameterDescriptions(ea.getName(), ea.parameters)

                descriptions.forEach { paramName, description ->
                    val answer = if (!description.description.isNullOrBlank()) {
                        languageModelConnector.query(
                            ssrfVerifier.getPromptWithNameAndDescription(
                                description.name,
                                description.description
                            )
                        )
                    } else {
                        languageModelConnector.query(
                            ssrfVerifier.getPromptWithNameOnly(
                                description.name
                            )
                        )
                    }

                    if (answer == SSRFVulnerabilityVerifier.SSRF_PROMPT_ANSWER_FOR_POSSIBILITY)
                        description.addVulnerabilityClass(VulnerabilityClass.SSRF)
                }

                actionVulnerabilityMapping[ea.getName()] = descriptions
            }
        }
    }

    /**
     * Extract descriptions from the Gene of body payloads.
     */
    private fun extractBodyParameterDescriptions(
        name: String,
        parameters: List<Param>
    ): MutableMap<String, ParamMapping> {
        val output = mutableMapOf<String, ParamMapping>()

        parameters.forEach { param ->
            if (param.name == "body") {
                param.seeGenes().forEach { gene ->
                    if (gene.name == "body") {
                        gene.getAllGenesInIndividual().forEach { geneInIndividual ->
                            output[geneInIndividual.name] =
                                ParamMapping(geneInIndividual.name, geneInIndividual.description)
                        }
                    } else {
                        output[gene.name] = ParamMapping(gene.name, gene.description)
                    }
                }
            }
        }

        return output
    }

    /**
     * Run the determined vulnerability class (from the classification)
     * analyzers
     */
    private fun execute() {
        if (config.problemType == EMConfig.ProblemType.REST) {
            // TODO: Run the tests again with generated value
            individualsInSolution.forEach { evaluatedIndividual ->
                val ea = evaluatedIndividual.evaluatedMainActions()[0].action as RestCallAction
                // Execute only the action which marked as a possible candidate
                if (actionVulnerabilityMapping.containsKey(ea.getName())) {
                    val link = ssrfVerifier.generateLink(ea.getName())
                }
            }
        }
    }

    /**
     * To verify vulnerability existence through [VulnerabilityVerifier]
     * TODO: [VulnerabilityVerifier] pending implementation
     */
    private fun verify() {
        if (config.problemType == EMConfig.ProblemType.REST) {
            individualsInSolution.forEach { eI ->
                val ea = eI.evaluatedMainActions()[0].action as RestCallAction
                val result = ssrfVerifier.verify(ea.getName())

                if (result) {
                    // TODO: Mark as vulnerable
                }
            }
        }
    }


}
